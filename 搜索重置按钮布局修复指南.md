# 搜索/重置按钮布局修复指南

## 问题描述

在使用 `table-bar` 组件的列表页面中，常见以下两个问题：

1. **布局问题**：搜索和重置按钮覆盖在最后一行筛选框上
2. **功能问题**：点击重置按钮后，筛选条件没有清空或清空了但没有重新查询数据

## 解决方案

### 第一步：修复按钮覆盖问题（前端）

在 `<el-form>` 标签上添加 `style="padding-bottom: 50px;"`，为搜索/重置按钮预留空间。

```vue
<!-- 修改前 -->
<el-form :model="queryParams" ref="searchFormRef" label-width="82px">
  <el-row :gutter="20">
    <!-- 筛选框内容 -->
  </el-row>
</el-form>

<!-- 修改后 -->
<el-form :model="queryParams" ref="searchFormRef" label-width="82px" style="padding-bottom: 50px;">
  <el-row :gutter="20">
    <!-- 筛选框内容 -->
  </el-row>
</el-form>
```

### 第二步：更新重置事件绑定（前端）

将 `table-bar` 组件的 `@reset` 事件改为调用新的 `handleReset` 函数。

```vue
<!-- 修改前 -->
<table-bar
  :showTop="false"
  @search="search"
  @reset="resetForm(searchFormRef)"
  @changeColumn="changeColumn"
  :columns="columns"
>

<!-- 修改后 -->
<table-bar
  :showTop="false"
  @search="search"
  @reset="handleReset"
  @changeColumn="changeColumn"
  :columns="columns"
>
```

### 第三步：添加重置处理函数（前端）

在搜索函数附近添加 `handleReset` 函数，确保完整处理重置逻辑。

```javascript
/** 搜索按钮操作 */
const search = () => {
  queryParams.pageNum = 1
  getList()
}

/** 重置按钮操作 */
const handleReset = () => {
  // 1. 先重置查询参数（根据实际的queryParams字段修改）
  queryParams.字段1 = ''
  queryParams.字段2 = ''
  queryParams.字段3 = undefined
  queryParams.字段4 = undefined
  queryParams.pageNum = 1
  
  // 2. 再重置表单视图
  if (searchFormRef.value) {
    searchFormRef.value.resetFields()
  }
  
  // 3. 重新查询所有数据
  getList()
}
```

**⚠️ 重要提示**：
- 需要根据每个页面的实际 `queryParams` 字段进行修改
- 字符串类型字段重置为空字符串 `''`
- 数字类型字段重置为 `undefined`
- 页码 `pageNum` 重置为 `1`

## 完整示例

### 示例1：批次管理页面

```vue
<template>
  <div class="page-content">
    <table-bar
      :showTop="false"
      @search="search"
      @reset="handleReset"
      @changeColumn="changeColumn"
      :columns="columns"
    >
      <template #top>
        <el-form :model="queryParams" ref="searchFormRef" label-width="82px" style="padding-bottom: 50px;">
          <el-row :gutter="20">
            <form-input
              label="批次名称"
              prop="batchName"
              @keyup.enter="search"
              v-model="queryParams.batchName"
            />
            <form-select
              label="批次状态"
              prop="status"
              v-model="queryParams.status"
              :options="statusOptions"
            />
            <el-col :xs="24" :sm="12" :lg="6">
              <el-form-item label="所属温室" prop="pastureId">
                <el-select v-model="queryParams.pastureId" filterable clearable placeholder="全部" style="width: 100%">
                  <el-option v-for="p in pastureOptions" :key="p.id" :label="p.name" :value="p.id" />
                </el-select>
              </el-form-item>
            </el-col>
            <el-col :xs="24" :sm="12" :lg="6">
              <el-form-item label="作物类型" prop="classId">
                <el-select v-model="queryParams.classId" filterable clearable placeholder="全部" style="width: 100%">
                  <el-option v-for="c in classOptions" :key="c.classId" :label="c.className" :value="c.classId" />
                </el-select>
              </el-form-item>
            </el-col>
          </el-row>
        </el-form>
      </template>
    </table-bar>
  </div>
</template>

<script setup lang="ts">
// 查询参数定义
const queryParams = reactive({
  pageNum: 1,
  pageSize: 10,
  batchName: '',
  status: '',
  pastureId: undefined as number | undefined,
  classId: undefined as number | undefined
})

/** 搜索按钮操作 */
const search = () => {
  queryParams.pageNum = 1
  getList()
}

/** 重置按钮操作 */
const handleReset = () => {
  // 重置查询参数
  queryParams.batchName = ''
  queryParams.status = ''
  queryParams.pastureId = undefined
  queryParams.classId = undefined
  queryParams.pageNum = 1
  
  // 重置表单
  if (searchFormRef.value) {
    searchFormRef.value.resetFields()
  }
  
  // 重新查询
  getList()
}
</script>
```

### 示例2：种植计划页面

```vue
<template>
  <div class="page-content">
    <table-bar
      :showTop="false"
      @search="search"
      @reset="handleReset"
      @changeColumn="changeColumn"
      :columns="columns"
    >
      <template #top>
        <el-form :model="queryParams" ref="searchFormRef" label-width="82px" style="padding-bottom: 50px;">
          <el-row :gutter="20">
            <form-input
              label="计划名称"
              prop="planName"
              @keyup.enter="search"
              v-model="queryParams.planName"
            />
            <el-col :xs="24" :sm="12" :lg="6">
              <el-form-item label="计划年份" prop="planYear">
                <el-date-picker
                  v-model="queryParams.planYear"
                  type="year"
                  placeholder="选择年份"
                  format="YYYY"
                  value-format="YYYY"
                  style="width: 100%"
                />
              </el-form-item>
            </el-col>
            <form-select
              label="计划类型"
              prop="planType"
              v-model="queryParams.planType"
              :options="planTypeOptions"
            />
            <form-select
              label="计划状态"
              prop="planStatus"
              v-model="queryParams.planStatus"
              :options="statusOptions"
            />
          </el-row>
        </el-form>
      </template>
    </table-bar>
  </div>
</template>

<script setup lang="ts">
// 查询参数定义
const queryParams = reactive({
  pageNum: 1,
  pageSize: 10,
  planName: '',
  planYear: '',
  planType: '',
  planStatus: '',
  classId: undefined as number | undefined
})

/** 搜索按钮操作 */
const search = () => {
  queryParams.pageNum = 1
  getList()
}

/** 重置按钮操作 */
const handleReset = () => {
  // 重置查询参数
  queryParams.planName = ''
  queryParams.planYear = ''
  queryParams.planType = ''
  queryParams.planStatus = ''
  queryParams.classId = undefined
  queryParams.pageNum = 1
  
  // 重置表单
  if (searchFormRef.value) {
    searchFormRef.value.resetFields()
  }
  
  // 重新查询
  getList()
}
</script>
```

## 修改检查清单

修改完成后，请逐项检查：

- [ ] 表单是否添加了 `style="padding-bottom: 50px;"`
- [ ] `@reset` 事件是否改为 `@reset="handleReset"`
- [ ] 是否添加了 `handleReset` 函数
- [ ] `handleReset` 函数中是否清空了所有 `queryParams` 字段
- [ ] 是否正确设置了字段类型（字符串用 `''`，数字用 `undefined`）
- [ ] 是否将 `pageNum` 重置为 `1`
- [ ] 是否调用了 `searchFormRef.value.resetFields()`
- [ ] 是否调用了 `getList()` 重新查询数据

## 测试步骤

1. **布局测试**：
   - 打开页面，检查搜索/重置按钮是否与筛选框有足够间距
   - 不应该覆盖在筛选框上

2. **重置功能测试**：
   - 输入各种筛选条件并点击搜索
   - 点击重置按钮
   - 检查所有筛选框是否清空
   - 检查列表是否显示所有数据（未筛选状态）

## 附加问题：后端字段歧义修复

如果页面使用了后端 SQL JOIN 查询，可能会遇到字段歧义问题，报错示例：

```
Column 'xxx' in where clause is ambiguous
```

### 问题原因

多个表中存在同名字段（如 `class_id`、`status` 等），SQL 无法确定应该使用哪个表的字段。

### 解决方案（后端 Java）

在 Service 实现类中，使用 `apply` 方法明确指定表别名：

```java
// 修改前（会报错）
if (entity.getFieldName() != null) {
    queryWrapper.eq(Entity::getFieldName, entity.getFieldName());
}

// 修改后（明确指定表别名 b）
if (entity.getFieldName() != null) {
    queryWrapper.apply("b.field_name = {0}", entity.getFieldName());
}
```

**示例**：批次管理的作物类型和状态筛选

```java
// AgricultureCropBatchServiceImpl.java
@Override
public List<AgricultureCropBatch> getCropBatchWithClassImages(AgricultureCropBatch agricultureCropBatch) {
    LambdaQueryWrapper<AgricultureCropBatch> queryWrapper = new LambdaQueryWrapper<>();
    
    // 批次名称筛选（不需要表别名）
    if (StringUtils.isNotEmpty(agricultureCropBatch.getBatchName())) {
        queryWrapper.like(AgricultureCropBatch::getBatchName, agricultureCropBatch.getBatchName());
    }
    
    // 作物类型筛选（需要表别名，因为 JOIN 了 agriculture_class 表）
    if (agricultureCropBatch.getClassId() != null) {
        queryWrapper.apply("b.class_id = {0}", agricultureCropBatch.getClassId());
    }
    
    // 所属温室筛选（不需要表别名）
    if (agricultureCropBatch.getPastureId() != null) {
        queryWrapper.eq(AgricultureCropBatch::getPastureId, agricultureCropBatch.getPastureId());
    }
    
    // 批次状态筛选（需要表别名，因为 JOIN 了 sys_user 表，可能有 status 字段）
    if (StringUtils.isNotEmpty(agricultureCropBatch.getStatus())) {
        queryWrapper.apply("b.status = {0}", agricultureCropBatch.getStatus());
    }
    
    return agricultureCropBatchMapper.selectCropBatchWithClassImages(queryWrapper);
}
```

## 常见问题

### Q1: 为什么要用 `padding-bottom: 50px;` 而不是其他方式？

A: `table-bar` 组件的搜索/重置按钮使用了绝对定位（`position: absolute`），默认距离底部 20px。通过给表单添加底部内边距，可以为按钮预留空间，避免覆盖筛选框。

### Q2: 可以直接修改 `table-bar` 组件的 `topButtons` 属性吗？

A: 不推荐。`topButtons` 控制按钮距离底部的距离，如果设置太大，按钮会跑到顶部；设置太小，又会覆盖筛选框。使用 `padding-bottom` 是更可靠的方案。

### Q3: 为什么要先重置参数，再重置表单，最后查询？

A: 这个顺序确保数据一致性：
1. 先清空查询参数，确保逻辑状态正确
2. 再清空表单视图，确保 UI 状态正确
3. 最后查询数据，获取完整列表

### Q4: 可以只调用 `resetForm()` 吗？

A: 不可以。`resetForm()` 只会重置表单视图到初始值，但不会清空 `queryParams` 对象，也不会触发重新查询。必须手动清空所有查询参数并调用 `getList()`。

## 总结

这个修复方案解决了两个关键问题：

1. **布局问题**：通过 `padding-bottom: 50px;` 为按钮预留空间
2. **功能问题**：通过 `handleReset` 函数完整处理重置逻辑

按照本指南修改后，所有使用 `table-bar` 组件的列表页面都能正常使用搜索和重置功能。

---

**文档版本**: v1.0  
**更新日期**: 2025-12-31  
**适用项目**: greenhouse-management-web

